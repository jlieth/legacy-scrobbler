import datetime
import hashlib
import unittest
from urllib.parse import urlparse, parse_qs, unquote
from typing import Callable

import httmock
import requests

from legacy_scrobbler.listen import Listen
from legacy_scrobbler import Network
from legacy_scrobbler.exceptions import (
    HardFailureError,
    RequestsError,
    ClientBannedException,
    BadAuthException,
    BadTimeException,
    BadSessionError,
    SubmissionWithoutListensError,
)


class NetworkTests(unittest.TestCase):
    """Tests for legacy_scrobbler.network.Network"""

    def setUp(self):
        self.network = Network(
            name="ScrobblerNetwork",
            username="testuser",
            password_hash="3858f62230ac3c915f300c664312c63f",
            handshake_url="http://somescrobblernetwork.com/handshake",
        )

    @staticmethod
    def simple_request_callback(content="", status_code=200) -> Callable:
        """
        Wrapper function that returns a function for use as a httmock callback.
        The callback function will return a request with the content and
        status_code given to the wrapper function.

        :param content: Content of the response object of the callback.
        :param status_code: Status code of the response object of the callback.
        :return: The callable function
        """

        @httmock.all_requests
        def inner(url, request):
            return httmock.response(
                content=content, status_code=status_code, request=request
            )

        return inner

    @staticmethod
    def required_params_present(required: list, received: list) -> bool:
        """
        Compares two lists against each other to find out if all elements in
        the `required` list are in the `received` list.

        :param required: list (of strings)
        :param received: list (of strings)
        :return: bool
        """
        return False not in [x in received for x in required]


class HandshakeTests(NetworkTests):
    """
    Tests for legacy_scrobbler.network.Network.handshake() and
    legacy_scrobbler.network.Network._process_handshake_response()
    """

    def test_handshake_request(self):
        """
        Tests legacy_scrobbler.network.Network.handshake() for protocol
        conformance. Basically, the callback for the handshake request
        implements the server side of the scrobbler protocol for handshakes
        and checks the request generated by the handshake call.
        """

        @httmock.all_requests
        def validate_handshake(url, request):
            """This is the callback for a handshake request."""
            # handshake method should be GET
            self.assertEqual(request.method, "GET")

            # extract received query params from request
            query_params = parse_qs(urlparse(request.url).query)

            # check that all required params present
            required = ["hs", "p", "c", "v", "u", "t", "a"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["hs"], "true")
            self.assertEqual(query_params["p"], "1.2")
            self.assertEqual(query_params["c"], self.network.CLIENT_NAME)
            self.assertEqual(query_params["v"], self.network.CLIENT_VERSION)
            self.assertEqual(query_params["u"], "testuser")
            self.assertTrue(query_params["t"].isnumeric())

            # calculate expected auth and compare to submitted auth
            timestamp = query_params["t"].encode("utf-8")
            password_hash = "3858f62230ac3c915f300c664312c63f".encode("utf-8")
            auth = hashlib.md5(password_hash + timestamp).hexdigest()
            self.assertEqual(query_params["a"], auth)

            # bogus (but successful) handshake response content
            content = "OK\nsession\nurl\nurl\n"
            return httmock.response(content=content, status_code=200, request=request)

        with httmock.HTTMock(validate_handshake):
            self.network.handshake()

    def test_handshake_request_on_status_exception(self):
        """
        Tests legacy_scrobbler.network.Network.handshake() with a response
        status code of 500. Responses with a different status code than 200
        during the handshake phase should be counted as a hard failure, so
        a HardFailureError should be raised in this case.
        """
        with httmock.HTTMock(self.simple_request_callback(status_code=500)):
            self.assertRaises(HardFailureError, self.network.handshake)

    def test_handshake_request_on_requests_exception(self):
        """
        Tests legacy_scrobbler.network.Network.handshake() when the requests
        attempt raises a requests.exceptions.RequestException. Should raise
        a legacy_scrobbler.exceptions.RequestsError.
        """

        @httmock.all_requests
        def raises_requests_exception(url, request):
            raise requests.exceptions.RequestException()

        with httmock.HTTMock(raises_requests_exception):
            self.assertRaises(RequestsError, self.network.handshake)

    def test_handshake_response_processing_on_success(self):
        """
        Tests legacy_scrobbler.network.Network._process_handshake_response()
        with a successful handshake as server response. After processing,
        the information from the response should be saved in the network
        object.
        """
        # create callback with the a bogus (but successful) response
        response_content = "OK\nsessionid\nnowplaying_url\nscrobble_url\n"
        callback = self.simple_request_callback(response_content)

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.network._process_handshake_response(response)

        # after processing, the content of the response should be saved to the network object
        self.assertEqual(self.network.session, "sessionid")
        self.assertEqual(self.network.nowplaying_url, "nowplaying_url")
        self.assertEqual(self.network.scrobble_url, "scrobble_url")

    def test_handshake_response_processing_on_banned(self):
        """
        Tests legacy_scrobbler.network.Network._process_handshake_response()
        with the server response "BANNED". This response should raise
        a ClientBannedException.
        """
        # create callback that returns a response with "BANNED" as content
        callback = self.simple_request_callback(content="BANNED")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.assertRaises(
                ClientBannedException,
                self.network._process_handshake_response,
                response,
            )

    def test_handshake_response_processing_on_badauth(self):
        """
        Tests legacy_scrobbler.network.Network._process_handshake_response()
        with the server response "BADAUTH". This response should raise
        a BadAuthException.
        """
        # create callback that returns a response with "BADAUTH" as content
        callback = self.simple_request_callback(content="BADAUTH")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.assertRaises(
                BadAuthException, self.network._process_handshake_response, response
            )

    def test_handshake_response_processing_on_badtime(self):
        """
        Tests legacy_scrobbler.network.Network._process_handshake_response()
        with the server response "BADTIME". This response should raise
        a BadTimeException.
        """
        # create callback that returns a response with "BADTIME" as content
        callback = self.simple_request_callback(content="BADTIME")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.assertRaises(
                BadTimeException, self.network._process_handshake_response, response
            )

    def test_handshake_response_processing_on_other_response(self):
        """
        Tests legacy_scrobbler.network.Network._process_handshake_response()
        with a server response that is not in protocol. This response should
        raise a HardFailureError.
        """
        # create callback that returns a response with "foobar" as content
        callback = self.simple_request_callback(content="foobar")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.assertRaises(
                HardFailureError, self.network._process_handshake_response, response
            )


class PostRequestSetup(NetworkTests):
    """
    Setup for the post request TestCases
    """

    def setUp(self):
        super().setUp()

        # set values on network usually received during handshake
        self.session = "fakesession"
        self.nowplaying_url = "http://somescrobblernetwork.com/nowplaying"
        self.submission_url = "http://somescrobblernetwork.com/submission"
        self.network.session = self.session
        self.network.nowplaying_url = self.nowplaying_url
        self.network.scrobble_url = self.submission_url

        # create Listen objects
        self.date = datetime.datetime.now(datetime.timezone.utc)
        self.listens = [
            Listen(
                date=self.date,
                artist_name="アーティスト",
                track_title="трек",
                album_title="Αλμπουμ",
                length=100,
                tracknumber=1,
                mb_trackid="जो कुछ",
                source="P",
                rating="L",
            ),
            Listen(
                date=self.date + datetime.timedelta(seconds=100),
                artist_name="Nghệ sĩ",
                track_title="跟踪",
                album_title="앨범",
                length=100,
                tracknumber=1,
                mb_trackid="যাই হোক",
                source="P",
                rating="L",
            ),
            Listen(
                date=self.date + datetime.timedelta(seconds=200),
                artist_name="Artist",
                track_title="Track",
                album_title="Album",
                length=100,
                tracknumber=1,
                mb_trackid="whatever",
                source="P",
                rating="L",
            ),
        ]


class PostRequestTests(PostRequestSetup):
    """
    Tests for legacy_scrobbler.network.Network._make_post_request() and
    legacy_scrobbler.network.Network._process_post_response(), which are
    internally used by the two types of post request (scrobble and
    nowplaying)
    """

    def test_post_request_without_session(self):
        """
        Tests legacy_scrobbler.network.Network._make_post_request() when no
        session id is saved in the Network object. This should raise a
        BadSessionError.
        """
        self.network.session = None
        self.assertRaises(
            BadSessionError,
            self.network._make_post_request,
            request_type="nowplaying",
            listens=self.listens,
        )
        self.network.session = self.session

    def test_post_request_without_listens(self):
        """
        Tests that legacy_scrobbler.network.Network._make_post_request() raises
        SubmissionWithoutListensError when called without listens.
        """
        self.assertRaises(
            SubmissionWithoutListensError,
            self.network._make_post_request,
            request_type="nowplaying",
            listens=None,
        )

    def test_post_request_on_status_exception(self):
        """
        Tests legacy_scrobbler.network.Network._make_post_request() with a
        response status code of 500. Responses with a different status code
        than 200 should be counted as a hard failure, so a HardFailureError
        should be raised in this case.
        """
        with httmock.HTTMock(self.simple_request_callback(status_code=500)):
            self.assertRaises(
                HardFailureError,
                self.network._make_post_request,
                request_type="nowplaying",
                listens=self.listens,
            )

    def test_post_request_on_requests_exception(self):
        """
        Tests legacy_scrobbler.network.Network._make_post_request() when the
        requests attempt raises a requests.exceptions.RequestException. Should
        raise a legacy_scrobbler.exceptions.RequestsError.
        """

        @httmock.all_requests
        def raises_requests_exception(url, request):
            raise requests.exceptions.RequestException()

        with httmock.HTTMock(raises_requests_exception):
            self.assertRaises(
                RequestsError,
                self.network._make_post_request,
                request_type="nowplaying",
                listens=self.listens,
            )

    def test_post_response_processing_on_badsession(self):
        """
        Tests legacy_scrobbler.network.Network._process_post_response()
        with the server response "BADSESSION". This response should raise
        a BadSessionError.
        """
        # create callback that returns a response with "BADSESSION" as content
        callback = self.simple_request_callback(content="BADSESSION")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.nowplaying_url)
            self.assertRaises(
                BadSessionError, self.network._process_post_response, response
            )

    def test_post_response_processing_on_other_response(self):
        """
        Tests legacy_scrobbler.network.Network._process_post_response()
        with a server response that is not in protocol. This response should
        raise a HardFailureError.
        """
        # create callback that returns a response with "foobar" as content
        callback = self.simple_request_callback(content="foobar")

        # mock the request and call the response processor
        with httmock.HTTMock(callback):
            response = requests.get(self.network.handshake_url)
            self.assertRaises(
                HardFailureError, self.network._process_post_response, response
            )


class NowplayingTests(PostRequestSetup):
    """Tests for legacy_scrobbler.network.Network.nowplaying()"""

    def test_nowplaying_request(self):
        """
        Tests legacy_scrobbler.network.Network.nowplaying() for protocol
        conformance. Basically, the callback for the nowplaying request
        implements the server side of the scrobbler protocol for nowplaying
        and checks the request generated by the nowplaying call.
        """

        @httmock.all_requests
        def validate_nowplaying(url, request):
            """This is the callback for a nowplaying request."""
            # nowplaying method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body)

            # check that all required params present
            required = ["s", "a", "t", "b", "l", "n", "m"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            listen = self.listens[0]
            self.assertEqual(query_params["s"], self.session)
            self.assertEqual(query_params["a"], listen.artist_name)
            self.assertEqual(query_params["t"], listen.track_title)
            self.assertEqual(query_params["b"], listen.album_title)
            self.assertEqual(query_params["l"], str(listen.length))
            self.assertEqual(query_params["n"], str(listen.tracknumber))
            self.assertEqual(query_params["m"], listen.mb_trackid)

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        with httmock.HTTMock(validate_nowplaying):
            self.network.nowplaying(self.listens[0])


class ScrobbleTests(PostRequestSetup):
    """Tests for legacy_scrobbler.network.Network.scrobble()"""

    def build_list_of_required_params(self) -> list:
        """
        Utility function that returns a list of strings with the query params
        that are required for a scrobble request of the listens in self.listens

        :return: list of required query params as strings
        """
        base_params = [
            "a[%i]",
            "t[%i]",
            "i[%i]",
            "o[%i]",
            "r[%i]",
            "l[%i]",
            "b[%i]",
            "n[%i]",
            "m[%i]",
        ]

        num_listens = len(self.listens)
        params = []
        for i in range(num_listens):
            for param in base_params:
                params.append(param % i)
        return params

    def test_submit_request(self):
        """
        Tests legacy_scrobbler.network.Network.scrobble() for protocol
        conformance. Basically, the callback for the scrobble request
        implements the server side of the scrobbler protocol for scrobbles
        and checks the request generated by the scrobble call.
        """

        @httmock.all_requests
        def validate_submit(url, request):
            """This is the callback for a scrobble request."""
            # scrobble method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body)

            # get list of required params and check that all are present
            required = self.build_list_of_required_params()
            required += "s"
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["s"], self.session)

            # check query params against self.listens
            for i, listen in enumerate(self.listens):
                self.assertEqual(query_params["a[%i]" % i], listen.artist_name)
                self.assertEqual(query_params["t[%i]" % i], listen.track_title)
                self.assertEqual(query_params["i[%i]" % i], str(listen.timestamp))
                self.assertEqual(query_params["o[%i]" % i], listen.source)
                self.assertEqual(query_params["r[%i]" % i], listen.rating)
                self.assertEqual(query_params["l[%i]" % i], str(listen.length))
                self.assertEqual(query_params["b[%i]" % i], listen.album_title)
                self.assertEqual(query_params["n[%i]" % i], str(listen.tracknumber))
                self.assertEqual(query_params["m[%i]" % i], listen.mb_trackid)

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        with httmock.HTTMock(validate_submit):
            self.network.scrobble(self.listens)
