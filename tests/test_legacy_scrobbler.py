import hashlib
import unittest
from unittest.mock import patch, Mock
from urllib.parse import urlparse, parse_qs, unquote

import httmock
import requests

from legacy_scrobbler.clients.legacy import LegacyScrobbler
from legacy_scrobbler.listen import Listens
from legacy_scrobbler.exceptions import (
    HardFailureError,
    RequestsError,
    BadSessionError,
    HandshakeError,
    SubmissionWithoutListensError,
)

from .data.listens import listens


class ScrobblerClientTests(unittest.TestCase):
    """Tests for legacy_scrobbler.client.LegacyScrobbler"""

    def setUp(self):
        # create client
        self.client = LegacyScrobbler(
            name="ScrobblerNetwork",
            username="testuser",
            password_hash="3858f62230ac3c915f300c664312c63f",
            handshake_url="http://somescrobblernetwork.com/handshake",
        )

        # set values on client usually received during handshake
        self.session = "fakesession"
        self.nowplaying_url = "http://somescrobblernetwork.com/nowplaying"
        self.submission_url = "http://somescrobblernetwork.com/submission"
        self.client.session = self.session
        self.client.nowplaying_url = self.nowplaying_url
        self.client.scrobble_url = self.submission_url

        self.listens = listens

    def test_handshake(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.handshake() for
        protocol conformance. Basically, the callback for the handshake request
        implements the server side of the scrobbler protocol for handshakes
        and checks the request generated by the handshake call.
        """

        @httmock.all_requests
        def validate_handshake(url, request):
            """This is the callback for a handshake request."""
            # handshake method should be GET
            self.assertEqual(request.method, "GET")

            # extract received query params from request
            query_params = parse_qs(urlparse(request.url).query)

            # check that all required params present
            required = ["hs", "p", "c", "v", "u", "t", "a"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["hs"], "true")
            self.assertEqual(query_params["p"], "1.2")
            self.assertEqual(query_params["c"], self.client.CLIENT_NAME)
            self.assertEqual(query_params["v"], self.client.CLIENT_VERSION)
            self.assertEqual(query_params["u"], "testuser")
            self.assertTrue(query_params["t"].isnumeric())

            # calculate expected auth and compare to submitted auth
            timestamp = query_params["t"].encode("utf-8")
            password_hash = "3858f62230ac3c915f300c664312c63f".encode("utf-8")
            auth = hashlib.md5(password_hash + timestamp).hexdigest()
            self.assertEqual(query_params["a"], auth)

            # bogus (but successful) handshake response content
            content = "OK\nsession\nurl\nurl\n"
            return httmock.response(content=content, status_code=200, request=request)

        with httmock.HTTMock(validate_handshake):
            self.client.handshake()

    def test_nowplaying_request(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.nowplaying() for
        protocol conformance. Basically, the callback for the nowplaying
        request implements the server side of the scrobbler protocol for
        nowplaying and checks the request generated by the nowplaying call.
        """

        @httmock.all_requests
        def validate_nowplaying(url, request: requests.PreparedRequest):
            """This is the callback for a nowplaying request."""
            # nowplaying method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body, keep_blank_values=True)

            # check that all required params present
            required = ["s", "a", "t", "b", "l", "n", "m"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            listen = self.listens[0]
            self.assertEqual(query_params["s"], self.session)
            self.assertEqual(query_params["a"], listen.artist_name)
            self.assertEqual(query_params["t"], listen.track_title)
            self.assertEqual(query_params["b"], listen.album_title or "")
            self.assertEqual(query_params["l"], str(listen.length or ""))
            self.assertEqual(query_params["n"], str(listen.tracknumber or ""))
            self.assertEqual(query_params["m"], listen.mb_trackid or "")

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        with httmock.HTTMock(validate_nowplaying):
            self.client.nowplaying(self.listens[0])

    def test_scrobble(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.scrobble() for
        protocol conformance. Basically, the callback for the scrobble request
        implements the server side of the scrobbler protocol for scrobbles
        and checks the request generated by the scrobble call.
        """

        @httmock.all_requests
        def validate_scrobble(url, request):
            """This is the callback for a scrobble request."""
            # scrobble method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body, keep_blank_values=True)

            # get list of required params and check that all are present
            required = self.build_list_of_required_params(listens_to_scrobble)
            required += "s"
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["s"], self.session)

            # check query params against self.listens
            for i, listen in enumerate(listens_to_scrobble):
                self.assertEqual(query_params["a[%i]" % i], listen.artist_name)
                self.assertEqual(query_params["t[%i]" % i], listen.track_title)
                self.assertEqual(query_params["i[%i]" % i], str(listen.timestamp))
                self.assertEqual(query_params["o[%i]" % i], listen.source)
                self.assertEqual(query_params["r[%i]" % i], listen.rating or "")
                self.assertEqual(query_params["l[%i]" % i], str(listen.length))
                self.assertEqual(query_params["b[%i]" % i], listen.album_title or "")
                self.assertEqual(
                    query_params["n[%i]" % i], str(listen.tracknumber or "")
                )
                self.assertEqual(query_params["m[%i]" % i], listen.mb_trackid or "")

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        listens_to_scrobble = self.listens[:50]
        with httmock.HTTMock(validate_scrobble):
            self.client.scrobble(listens_to_scrobble)

    @patch.object(LegacyScrobbler, "_in_case_of_failure")
    @patch.object(LegacyScrobbler, "handshake")
    def test_execute(self, mocked_handshake, mocked_in_case_of_failure):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler._execute_request()

        The method LegacyScrobbler._in_case_of_failure() is used a couple of
        times during _execute_request() and is being mocked during this test
        in order to check that it actually is being called.

        _execute_request() takes a callable as its first argument. The argument
        function is used to make the actual request. The argument callable can
        only be handshake, nowplaying or scrobble. During this test, the
        argument function needs to be a dummy function so we can determine
        the desired behaviour. However, since the input callable needs to be
        one of the mentioned methods, we'll need to mock one of those functions
        instead of just passing in a dummy function.

        Situations tested:
        - if the input callable raises a HardFailureError, _in_case_of_failure
          should be called
        - if the input callable raises a RequestsError, _in_case_of_failure
          should be called
        - if the input callable raises a BadSessionError, session should be
          unset and state set to "no_session"
        - if the input callable raises a HandshakeError, the same error should
          be re-raised
        - if the input callable raises a SubmissionWithoutListensError, the
          same error should be re-raised
        - on a successful request, the else_cb should be called
        - on an unsuccessful request, the else_cb should not be called
        - the finally_cb should be called on both a successful and an
          unsuccessful request

        :param mocked_handshake: Mock method of handshake
        :param mocked_in_case_of_failure: Mock method of _in_case_of_failure()
        """
        # we have to set function __name__ on the mocked handshake
        mocked_handshake.__name__ = "handshake"

        # if the input callable raises a HardFailureError, _in_case_of_failure
        # should be called
        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(method=self.client.handshake)
        mocked_in_case_of_failure.assert_called()
        mocked_in_case_of_failure.reset_mock()

        # if the input callable raises a RequestsError, _in_case_of_failure
        # should be called
        mocked_handshake.side_effect = RequestsError()
        self.client._execute_request(method=self.client.handshake)
        mocked_in_case_of_failure.assert_called()
        mocked_in_case_of_failure.reset_mock()

        # if the input callable raises a BadSessionError, session should be
        # unset and state set to "no_session"
        mocked_handshake.side_effect = BadSessionError()
        self.client._execute_request(method=self.client.handshake)
        self.assertIsNone(self.client.session)
        self.assertEqual(self.client.state, "no_session")

        # if the input callable raises a HandshakeError, the same error should
        # be re-raised
        mocked_handshake.side_effect = HandshakeError()
        self.assertRaises(
            HandshakeError, self.client._execute_request, method=self.client.handshake
        )

        # if the input callable raises a SubmissionWithoutListensError, the
        # same error should be re-raised
        mocked_handshake.side_effect = SubmissionWithoutListensError()
        self.assertRaises(
            SubmissionWithoutListensError,
            self.client._execute_request,
            method=self.client.handshake,
        )

        # on a successful request, the else_cb should be called
        else_cb = Mock()
        mocked_handshake.side_effect = None
        self.client._execute_request(method=self.client.handshake, else_cb=else_cb)
        else_cb.assert_called()

        # on an unsuccessful request, the else_cb should not be called
        else_cb = Mock()
        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(method=self.client.handshake, else_cb=else_cb)
        else_cb.assert_not_called()

        # the finally_cb should be called on both a successful and an
        # unsuccessful request
        finally_cb = Mock()
        mocked_handshake.side_effect = None
        self.client._execute_request(
            method=self.client.handshake, finally_cb=finally_cb
        )
        finally_cb.assert_called()
        finally_cb.reset_mock()

        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(
            method=self.client.handshake, finally_cb=finally_cb
        )
        finally_cb.assert_called()

    @staticmethod
    def required_params_present(required: list, received: list) -> bool:
        """
        Compares two lists against each other to find out if all elements in
        the `required` list are in the `received` list.

        :param required: list (of strings)
        :param received: list (of strings)
        :return: bool
        """
        is_present = [x in received for x in required]
        all_present = False not in is_present
        return all_present

    @staticmethod
    def build_list_of_required_params(l: Listens) -> list:
        """
        Utility function that returns a list of strings with the query params
        that are required for a scrobble request of the listens in self.listens

        :return: list of required query params as strings
        """
        base_params = [
            "a[%i]",
            "t[%i]",
            "i[%i]",
            "o[%i]",
            "r[%i]",
            "l[%i]",
            "b[%i]",
            "n[%i]",
            "m[%i]",
        ]

        num_listens = len(l)
        params = []
        for i in range(num_listens):
            for param in base_params:
                params.append(param % i)
        return params
