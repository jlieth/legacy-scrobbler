from collections import deque
import hashlib
import random
import unittest
from unittest.mock import patch, Mock, PropertyMock
from urllib.parse import urlparse, parse_qs, unquote

import httmock
import requests

from legacy_scrobbler.clients import base
from legacy_scrobbler.clients.legacy import LegacyScrobbler
from legacy_scrobbler.listen import Listens
from legacy_scrobbler.exceptions import (
    HardFailureError,
    RequestsError,
    BadSessionError,
    HandshakeError,
    SubmissionWithoutListensError,
)

from .data.listens import listens


class ScrobblerClientTests(unittest.TestCase):
    """Tests for legacy_scrobbler.client.LegacyScrobbler"""

    def setUp(self):
        # create client
        self.client = LegacyScrobbler(
            name="ScrobblerNetwork",
            username="testuser",
            password_hash="3858f62230ac3c915f300c664312c63f",
            handshake_url="http://somescrobblernetwork.com/handshake",
        )

        # set values on client usually received during handshake
        self.session = "fakesession"
        self.nowplaying_url = "http://somescrobblernetwork.com/nowplaying"
        self.submission_url = "http://somescrobblernetwork.com/submission"
        self.client.session = self.session
        self.client.nowplaying_url = self.nowplaying_url
        self.client.scrobble_url = self.submission_url

        self.listens = listens

    def test_handshake(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.handshake() for
        protocol conformance. Basically, the callback for the handshake request
        implements the server side of the scrobbler protocol for handshakes
        and checks the request generated by the handshake call.
        """

        @httmock.all_requests
        def validate_handshake(url, request):
            """This is the callback for a handshake request."""
            # handshake method should be GET
            self.assertEqual(request.method, "GET")

            # extract received query params from request
            query_params = parse_qs(urlparse(request.url).query)

            # check that all required params present
            required = ["hs", "p", "c", "v", "u", "t", "a"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["hs"], "true")
            self.assertEqual(query_params["p"], "1.2")
            self.assertEqual(query_params["c"], self.client.CLIENT_NAME)
            self.assertEqual(query_params["v"], self.client.CLIENT_VERSION)
            self.assertEqual(query_params["u"], "testuser")
            self.assertTrue(query_params["t"].isnumeric())

            # calculate expected auth and compare to submitted auth
            timestamp = query_params["t"].encode("utf-8")
            password_hash = "3858f62230ac3c915f300c664312c63f".encode("utf-8")
            auth = hashlib.md5(password_hash + timestamp).hexdigest()
            self.assertEqual(query_params["a"], auth)

            # bogus (but successful) handshake response content
            content = "OK\nsession\nurl\nurl\n"
            return httmock.response(content=content, status_code=200, request=request)

        with httmock.HTTMock(validate_handshake):
            self.client.handshake()

    def test_nowplaying_request(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.nowplaying() for
        protocol conformance. Basically, the callback for the nowplaying
        request implements the server side of the scrobbler protocol for
        nowplaying and checks the request generated by the nowplaying call.
        """

        @httmock.all_requests
        def validate_nowplaying(url, request: requests.PreparedRequest):
            """This is the callback for a nowplaying request."""
            # nowplaying method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body, keep_blank_values=True)

            # check that all required params present
            required = ["s", "a", "t", "b", "l", "n", "m"]
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            listen = self.listens[0]
            self.assertEqual(query_params["s"], self.session)
            self.assertEqual(query_params["a"], listen.artist_name)
            self.assertEqual(query_params["t"], listen.track_title)
            self.assertEqual(query_params["b"], listen.album_title or "")
            self.assertEqual(query_params["l"], str(listen.length or ""))
            self.assertEqual(query_params["n"], str(listen.tracknumber or ""))
            self.assertEqual(query_params["m"], listen.mb_trackid or "")

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        with httmock.HTTMock(validate_nowplaying):
            self.client.nowplaying(self.listens[0])

    def test_scrobble(self):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler.scrobble() for
        protocol conformance. Basically, the callback for the scrobble request
        implements the server side of the scrobbler protocol for scrobbles
        and checks the request generated by the scrobble call.
        """

        @httmock.all_requests
        def validate_scrobble(url, request):
            """This is the callback for a scrobble request."""
            # scrobble method should be POST
            self.assertEqual(request.method, "POST")

            # make sure that the request body is utf-8 encoded
            unquote(request.body, encoding="utf-8", errors="strict")

            # extract received query params from request body
            query_params = parse_qs(request.body, keep_blank_values=True)

            # get list of required params and check that all are present
            required = self.build_list_of_required_params(listens_to_scrobble)
            required += "s"
            received = query_params.keys()
            self.assertTrue(self.required_params_present(required, received))

            # extracted list of query params is a dict with the param as key
            # and param value as a list. {"param": ["value"]}
            # If a param was present more than once in the request, the list
            # of values would contain multiple items. This shouldn't happen.
            for key, val in query_params.items():
                self.assertEqual(len(val), 1)
                query_params[key] = val[0]

            # query values should equal expected values
            self.assertEqual(query_params["s"], self.session)

            # check query params against self.listens
            for i, listen in enumerate(listens_to_scrobble):
                self.assertEqual(query_params["a[%i]" % i], listen.artist_name)
                self.assertEqual(query_params["t[%i]" % i], listen.track_title)
                self.assertEqual(query_params["i[%i]" % i], str(listen.timestamp))
                self.assertEqual(query_params["o[%i]" % i], listen.source)
                self.assertEqual(query_params["r[%i]" % i], listen.rating or "")
                self.assertEqual(query_params["l[%i]" % i], str(listen.length))
                self.assertEqual(query_params["b[%i]" % i], listen.album_title or "")
                self.assertEqual(
                    query_params["n[%i]" % i], str(listen.tracknumber or "")
                )
                self.assertEqual(query_params["m[%i]" % i], listen.mb_trackid or "")

            # send response
            return httmock.response(content="OK\n", status_code=200, request=request)

        listens_to_scrobble = self.listens[:50]
        with httmock.HTTMock(validate_scrobble):
            self.client.scrobble(listens_to_scrobble)

    @patch.object(LegacyScrobbler, "_in_case_of_failure")
    @patch.object(LegacyScrobbler, "handshake")
    def test_execute(self, mocked_handshake, mocked_in_case_of_failure):
        """
        Tests legacy_scrobbler.client.legacy.LegacyScrobbler._execute_request()

        The method LegacyScrobbler._in_case_of_failure() is used a couple of
        times during _execute_request() and is being mocked during this test
        in order to check that it actually is being called.

        _execute_request() takes a callable as its first argument. The argument
        function is used to make the actual request. The argument callable can
        only be handshake, nowplaying or scrobble. During this test, the
        argument function needs to be a dummy function so we can determine
        the desired behaviour. However, since the input callable needs to be
        one of the mentioned methods, we'll need to mock one of those functions
        instead of just passing in a dummy function.

        Situations tested:
        - if the input callable raises a HardFailureError, _in_case_of_failure
          should be called
        - if the input callable raises a RequestsError, _in_case_of_failure
          should be called
        - if the input callable raises a BadSessionError, session should be
          unset and state set to "no_session"
        - if the input callable raises a HandshakeError, the same error should
          be re-raised
        - if the input callable raises a SubmissionWithoutListensError, the
          same error should be re-raised
        - on a successful request, the else_cb should be called
        - on an unsuccessful request, the else_cb should not be called
        - the finally_cb should be called on both a successful and an
          unsuccessful request

        :param mocked_handshake: Mock method of handshake
        :param mocked_in_case_of_failure: Mock method of _in_case_of_failure()
        """
        # we have to set function __name__ on the mocked handshake
        mocked_handshake.__name__ = "handshake"

        # if the input callable raises a HardFailureError, _in_case_of_failure
        # should be called
        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(method=self.client.handshake)
        mocked_in_case_of_failure.assert_called()
        mocked_in_case_of_failure.reset_mock()

        # if the input callable raises a RequestsError, _in_case_of_failure
        # should be called
        mocked_handshake.side_effect = RequestsError()
        self.client._execute_request(method=self.client.handshake)
        mocked_in_case_of_failure.assert_called()
        mocked_in_case_of_failure.reset_mock()

        # if the input callable raises a BadSessionError, session should be
        # unset and state set to "no_session"
        mocked_handshake.side_effect = BadSessionError()
        self.client._execute_request(method=self.client.handshake)
        self.assertIsNone(self.client.session)
        self.assertEqual(self.client.state, "no_session")

        # if the input callable raises a HandshakeError, the same error should
        # be re-raised
        mocked_handshake.side_effect = HandshakeError()
        self.assertRaises(
            HandshakeError, self.client._execute_request, method=self.client.handshake
        )

        # if the input callable raises a SubmissionWithoutListensError, the
        # same error should be re-raised
        mocked_handshake.side_effect = SubmissionWithoutListensError()
        self.assertRaises(
            SubmissionWithoutListensError,
            self.client._execute_request,
            method=self.client.handshake,
        )

        # on a successful request, the else_cb should be called
        else_cb = Mock()
        mocked_handshake.side_effect = None
        self.client._execute_request(method=self.client.handshake, else_cb=else_cb)
        else_cb.assert_called()

        # on an unsuccessful request, the else_cb should not be called
        else_cb = Mock()
        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(method=self.client.handshake, else_cb=else_cb)
        else_cb.assert_not_called()

        # the finally_cb should be called on both a successful and an
        # unsuccessful request
        finally_cb = Mock()
        mocked_handshake.side_effect = None
        self.client._execute_request(
            method=self.client.handshake, finally_cb=finally_cb
        )
        finally_cb.assert_called()
        finally_cb.reset_mock()

        mocked_handshake.side_effect = HardFailureError()
        self.client._execute_request(
            method=self.client.handshake, finally_cb=finally_cb
        )
        finally_cb.assert_called()

    @staticmethod
    def required_params_present(required: list, received: list) -> bool:
        """
        Compares two lists against each other to find out if all elements in
        the `required` list are in the `received` list.

        :param required: list (of strings)
        :param received: list (of strings)
        :return: bool
        """
        is_present = [x in received for x in required]
        all_present = False not in is_present
        return all_present

    @staticmethod
    def build_list_of_required_params(l: Listens) -> list:
        """
        Utility function that returns a list of strings with the query params
        that are required for a scrobble request of the listens in self.listens

        :return: list of required query params as strings
        """
        base_params = [
            "a[%i]",
            "t[%i]",
            "i[%i]",
            "o[%i]",
            "r[%i]",
            "l[%i]",
            "b[%i]",
            "n[%i]",
            "m[%i]",
        ]

        num_listens = len(l)
        params = []
        for i in range(num_listens):
            for param in base_params:
                params.append(param % i)
        return params


class WaitingToBeMoved:
    @patch.object(base.Delay, "is_active", new_callable=PropertyMock)
    @patch.object(LegacyScrobbler, "_execute_request")
    def test_tick(self, mocked_execute_request: Mock, mocked_is_active: Mock):
        """
        Tests legacy_scrobbler.client.LegacyScrobbler.tick()

        The property legacy_scrobbler.delay.Delay.is_active is mocked during
        this test to simulate a specific program state.

        The method LegacyScrobbler._execute_request() is mocked during this
        test to determine if tick() has called the method and which arguments
        were given to it.

        Situations tested:
        - if self.state is "no_session" but delay.is_active returns
          True, nothing should happen (that is, _execute_request should not
          be called)
        - if self.state is "idle" and neither self.np is set nor self.queue
          contains any listens, nothing should happen (that is,
          _execute_request should not be called)
        - if self.state is "no_session" and delay.is_active returns False,
          execute_request should be called with the arguments:
            method=self.handshake
            else_cb=self.on_handshake_success
            finally_cb=self.on_handshake
        - if self.state is "idle" and self.np is set, _execute_request should
          be called with the arguments:
            method=self.nowplaying
            else_cb=self.on_nowplaying_success
            arg=self.np
        - if self.state is "idle" and self.queue contains listens,
          _execute_request should be called with the arguments:
            method=self.scrobble
            else_cb=self.on_scrobble_success
            arg=deque(list(self.queue)[:50])


        :param mocked_execute_request: Mock method of _execute_request
        :param mocked_is_active: Mock method of delay.is_active
        """

        # if self.state is "no_session" but delay.is_active returns
        # True, nothing should happen (that is, _execute_request should not
        # be called)
        self.client.state = "no_session"
        mocked_is_active.return_value = True
        self.client.tick()
        mocked_execute_request.assert_not_called()

        # if self.state is "idle" and neither self.np is set nor self.queue
        # contains any listens, nothing should happen (that is,
        # _execute_request should not be called)
        self.client.state = "idle"
        self.client.np = None
        self.client.queue.clear()
        self.client.tick()
        mocked_execute_request.assert_not_called()

        # if self.state is "no_session" and delay.is_active returns False,
        # execute_request should be called with the arguments:
        #   method=self.handshake
        #   else_cb=self.on_handshake_success
        #   finally_cb=self.on_handshake
        self.client.state = "no_session"
        mocked_is_active.return_value = False
        self.client.tick()
        mocked_execute_request.assert_called_with(
            method=self.client.handshake,
            else_cb=self.client.on_handshake_success,
            finally_cb=self.client.on_handshake,
        )
        mocked_execute_request.reset_mock()

        # if self.state is "idle" and self.np is set, _execute_request should
        # be called with the arguments:
        #   method=self.nowplaying
        #   else_cb=self.on_nowplaying_success
        #   arg=self.np
        self.client.state = "idle"
        self.client.np = self.listens[0]
        self.client.tick()
        mocked_execute_request.assert_called_with(
            method=self.client.nowplaying,
            else_cb=self.client.on_nowplaying_success,
            arg=self.client.np,
        )
        # unset self.client.np
        self.client.np = None

        # if self.state is "idle" and self.queue contains listens,
        # _execute_request should be called with the arguments:
        #   method=self.scrobble
        #   else_cb=self.on_scrobble_success
        #   arg=deque(list(self.queue)[:50])
        self.client.state = "idle"
        self.client.add_listens(self.listens)
        self.client.tick()
        mocked_execute_request.assert_called_with(
            method=self.client.scrobble,
            else_cb=self.client.on_scrobble_success,
            arg=deque(list(self.client.queue)[:50]),
        )

    def test_set_nowplaying(self):
        """Tests legacy_scrobbler.client.LegacyScrobbler.send_nowplaying()"""
        self.client.send_nowplaying(self.listens[0])
        self.assertEqual(self.client.np, self.listens[0])

        # unset np
        self.client.np = None

    def test_enqueue(self):
        """
        Tests legacy_scrobbler.client.LegacyScrobbler.add_listens()

        Uses some listens from self.listens as initial queue, shuffles the
        list of other listens and calls add_listens() with the shuffled
        list. Resulting queue should be in chronological order (same as
        self.listens, just as a deque).
        """
        # initialize queue as [2, 4] (indices are of course zero-indexed)
        queue = [self.listens[1], self.listens[3]]
        self.client.queue = deque(queue)

        # enqueue other listens in order [3, 5, 1]
        others = [self.listens[0], self.listens[2], self.listens[4]]
        random.shuffle(others)
        self.client.add_listens(others)

        # queue should be in same order [1, 2, 3, 4, 5] as self.listens now
        self.assertEqual(self.client.queue, deque(self.listens))

    def test_sort_queue(self):
        """Tests legacy_scrobbler.client.LegacyScrobbler._sort_queue()"""
        # set the shuffled self.listens as queue
        queue = self.listens[:]
        random.shuffle(queue)
        self.client.queue = deque(queue)

        # queue should be in same order as self.listens after sorting (but a deque)
        self.client._sort_queue()
        expected = deque(self.listens)
        self.assertEqual(self.client.queue, expected)

    def test_in_case_of_failure(self):
        """
        Test legacy_scrobbler.client.LegacyScrobbler._in_case_of_failure()

        The method should:
        - increase failure counter
        - call legacy_scrobbler.delay.Delay.increase()
        - set internal state to "no_session" if failure counter >= 3
        """
        # assert initial state of zero failures, zero delay
        self.assertEqual(self.client.hard_fails, 0)
        self.assertEqual(self.client.delay._seconds, 0)

        # should increase failure counter
        self.client._in_case_of_failure()
        self.assertEqual(self.client.hard_fails, 1)

        # should call _increase_delay()
        # mocking _increase_delay to assure that it was called
        with patch.object(base.Delay, "increase") as mock_method:
            self.client._in_case_of_failure()
            mock_method.assert_called()

        # should set internal state to "no_session" if failure counter >= 3
        # setting initial state to something else
        self.client.state = "idle"
        self.client.hard_fails = 23
        self.client._in_case_of_failure()
        self.assertEqual(self.client.state, "no_session")

        # reset
        self.client.hard_fails = 0
        self.client.delay.reset()
